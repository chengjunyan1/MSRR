# MSRR System
High-Level System and Mediator for Modular Self-Reconfigurable Robot (MSRR)

*by Cheng Jun-Yan*

**Prerequisite:** opencv2, apriltags3, ros, parrot-olympe (for drone control), parrot-sphinx (for drone simulation)

![image](https://github.com/chengjunyan1/MSRR-System/raw/master/system.png)

This repository contains a MSRR High-Lvel System I developed for the term project in WPI RBE502 ROBOT CONTROL. The project goal is to make a MSRR and implemente self-reconfiguration. We didn't manufacture the physical robot at the end, but finished the goal in simulation. This is a team project (3 students), my two teammates are ME and EE student respectively, they focused on the hardware parts including the mechanical design, CAD, URDF, dynamical modeling, motor control, ROS simultion (not include the drone). *Please note that this repository do not show the whole project, it only shows my part in the project.* 

The Final Repors folder contains my part in written final report and final presentation ppt which are related to the content of this repository. 

The input of the system is defined by the *Coordinator* which provides the coordinates of all robot modules (implemented by apriltags, coordinated by a drone). *Planner* output a high-level plan which is a sequence of action primitives (by a self-reconfiguration and self-assembly planner). Then the system output which is path or trajectory generated by *Actuator* (implemented by a JPS path planner). And then sent to the robot by *Mediator Server* (use socket to communicate with the high-level system, then relay to other systems(e.g. real robots, ros) with specific protocols). 

This system could be runs on both real robot and simulation by modifying the signals sent by the mediator server. Its a high-level system which means that the system runs regardless of the low-level implementation of real robot (such as motor control). 

When runs on different hardware platform, only the definition of connectors in planner and the implementation of MOVE primitive in actuator, and the parameters in coordinator need to be modified.

The Self-Reconfiguration Planning algorithm contained in this system is designed by myself based on many previous literatures (see Final Report - my part). 

## Hardware Platform

![image](https://github.com/chengjunyan1/MSRR-System/raw/master/md.png)

The above image showed the mechanical design and DOF of one module. 

***This image comes from my teammates, CAD model from Erik Wang, the rightmost robot model from Raunak Hosangadi.***

## I. How to use:

1.Run BootServer.py (args: 1 for listen ros. none for server., also need run the roscore)

2.Run DroneScript.py (args: 1 for init, none for keep streaming.)

3.Run MSRRScript.py (args: 1 for reset stage, none for continue.)

## II. How to Install Apriltags:

1.Download apriltags from https://github.com/AprilRobotics/apriltag (Or directly use apriltags.zip in /Coordinator)

2.Rename the folder 'apriltags', put it in Coordinator/

3.Enter the folder, then build it:

cmake .

make

## III. How to Activate drone env:

source ~/code/parrot-groundsdk/./products/olympe/linux/env/shell

## IV. How to launch drone simulation:

sudo systemctl start firmwared

sphinx /opt/parrot-sphinx/usr/share/sphinx/drones/anafi4k.drone::stolen_interface=

## V. How to modify

1.Write the MSRRScript.py to plan a high level task

2.Write the DroneScript.py to define the behavior of Drone. Or use Coordinator/drone.py to directly control it.

3.Modify configs.py and also parameters for planner, coordinator and actuator.

## Sample

![image](https://github.com/chengjunyan1/MSRR-System/raw/master/sample.png)

Upper left is a gazebo simulation environment. Lower left is the terminal of the drone simulation that monitoring the status of the drone (the drone simulator is from parrot, see https://developer.parrot.com/). Upper middle showed the video streamming from the drone camera which shows the current position of each module. Lower middle is the ROS core showed the messages sent from the mediator server to each module. Upper right showed the path planned by the path planner (when planning, the path will be showed in this windows, after planning, it shows the target position for each module). Lower right is the terminal of the mediator server showing the message relayed by the server, on the image, its sending a path generated by the path planner based on the result from reconfiguration planner to the corresponding modules parrallelly. 
